---
title : "[JAVA] Class 이론 정리 - 3"
layout: single
excerpt: "[접근 제한자, Getter 메소드, Setter 메소드, 어노테이션]"
toc: true
toc_sticky: true
date: 2022-09-21
categories: [Java]
tag: [class, field, method, constructor, Access_Modifier, Getter, Setter, Annotation]
author_profile: false
sidebar:
    nav: "docs"
---

# Chapter 06. 클래스 정리 - 2

## 8. 접근 제한자   
main() 메소드를 가지지 않는 대부분의 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스이다.   
`라이브러리 클래스`를 설계할 때에는 *외부 클래스에서 접근할 수 있는 멤버* 와 *접근할 수 없는 멤버* 로 구분해서 필드, 생성자, 메소드를 설계하는 것이 바람직하다.   
객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해달 필드에 접근하지 못하도록 제한할 필요가 있다.   

자바는 이러한 기능을 구현하기 위해 <u>접근제한자(Access Modifier)</u> 를 제공하고 있다.   

접근 제한자는 public, protected, default, private 와 같이 네 가지 종류가 있다.   
- `public` 점근 제한자는 외부 클래스가 자유롭게 사용할 수 있는 공개 멤버를 만든다.   
- `protected` 접근 제한자는 같은 패키지 또는 자식 클래스에서 사용할 수 있는 멤버를 만든다.    
- `private` 접근 제한자는 단어의 뜻 그대로 개인적인 것이라 외부에 노출되지 않는 멤버를 만든다.   
-  위 세가지 접근 제한자가 적용되지 않은 멤버는 `default` 접근 제한을 가진다.   
default 접근 제한자는 같은 패키지에 소속된 클래스에서만 사용할 수 있는 멤버를 만든다.   

> 
| 접근제한 | 적용 대상 | 접근할 수 없는 클래스 |
|----------|---------------|------------------------|
|public|클래스, 필드, 생성자, 메소드|없음|
|protected|필드, 생성자, 메소드|자식 클래스가 아닌 다른 패키지에 소속된 클래스|
|default|클래스, 필드, 생성자, 메소드|다른 패키지에 소속된 클래스|
|private|필드, 생성자, 메소드|모든 외부 클래스|

### 8.1 클래스의 접근 제한   
클래스를 선언할 때 고려해야할 사항은 패키지 내에서만 사용할 것인지,   
아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 한다.   
클래스에 적용할 수 있는 접근 제한은 public 과 default 단 두 가지 이다. 
- ex) `public` 과 `default` 형식
```java
    //default 접근 제한
    Class 클래스 { ... }

    //public 접근 제한
    public class 클래스 { ... } 
```   

#### default 접근 제한   
클래스를 선언할 때 `public을 생략`했다면 클래스는 default 접근 제한을 가진다.   
클래스가 default 접근 제한을 가지게 되면 같은 패키지에서는 아무런 제한 없이 사용할 수 있지만    
*다른 패키지에서는 사용할 수 없도록 제한*된다. 

#### public 접근 제한   
클래스를 선언할 때 public 접근 제한자를 붙였다면 클래스는 public 접근 제한을 가진다.   
클래스가 public 접근 제한을 가지게 되면 같은 패키지뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용할 수 있다.   

- 클래스를 다른 개발자가 사용할 수 있도록 라이브러리 클래스로 개발되어야 한다면,   
반드시 public 접근 제한을 갖도록 해야 한다.  
인터넷으로 배포되는 라이브러리 클래스들도 모두 public 접근 제한을 가지고 있다. 

ex) 세 클래스를 이클립스에서 작성해 보면서 이클립스가 어떤 컴파일 에러를 발생시키는지 살펴보기   
>`A.java` 클래스의 접근 제한    

```java
package sec13.exam01_class_access.package1;

    class A {}  //default 접근 제한
```

> `B.java` 클래스의 접근 제한   

```java
package sec13.exam01_class_access.package1;

    public class B {
          A a;    //(o) ← A 클래스 접근 가능 (필드로 선언할 수 있음)
}
```   

B 클래스는 A 클래스와 같은 패키지이므로 A 클래스에 접근이 가능하다.   
그래서 B 클래스에서 A 클래스를 이용하여 필드 선언 및 생성자/메소드 내부에서 변수 선언이 가능하다.   


> `C.java` 클래스의 접근 제한    

```java
package sec13.exam01_class_access_package2; // 패키지가 다름

import sec13.exam01_class_access.package1.*;

    public class C {
      A a;    // (x) ← A 클래스 접근 불가(컴파일 에러)
      B b;    // (o) 
    }
```   
C 클래스는 A 클래스와 다른 패키지이므로 `default 접근이 제한`된 A 클래스에는 접근이 되지 않지만,   
public으로 공개된 B 클래스는 접근이 가능하다.   
그래서 C 클래스에서 B 클래스를 이용하여 필드 선언 및 생성자/메소드 내부에서 변수 선언이 가능하다. 

### 8.2 생성자의 접근 제한  
객체를 생성하기 위해서는 new 연산자로 생성자를 호출해야 한다.   
생성자가 어떤 접근 제한을 갖느냐에 따라 `호출 가능 여부`가 결정된다.   

> 생성자는 다음과 같이 public, protected, default, private 접근 제한은 가질 수 있다.   

```java
public class ClassName {

    // public 접근 제한
    public ClassName(...) { ... }

    // protected 접근 제한 
    protected ClassName(...) { ... }  

    // default 접근 제한
    ClassName(...) { ... }  

    // private 접근 제한
    private ClassName(...) { ... }    
}
```

클래스에 생성자를 선언하지 않으면 컴파일러에 의해 자동적으로 기본 생성자가 추가된다.   
자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다.   

클래스가 default 접근 제한을 가지면 기본 생성자도 default 접근 제한을 가지고,   
클래스가 public 접근 제한을 가지면 기본 생성자도 public 접근 제한을 가진다. 

- publc   
    - 생성자 : 클래스(...)   
모든 패키지에서 아무런 제한 없이 생성자를 호출할 수 있도록 한다.    
셍성자가 public 접근 제한을 가진다면 클래스 사용이 같은 패키지로 한정되므로,   
비록 생성자가 public 접근 제한을 가지더라도 같은 패키지에서만 생성자를 호출할 수 있다. 

- protected   
    - 생성자 : 클래스(...)   
protected 접근 제한은 default 접근 제한과 마찬가지로 같은 패키지에 속하는 클래스에서 생성자를 호출할 수 있도록 한다.   
차이점은 다른 패키지에 속한 클래스가 해당 클래스의 자식(Child) 클래스라면 생성자를 호출할 수 있다.   

- default   
    - 생성자 : 클래스(...)   
생성자를 선언할 때 public 또는 private 를 생략했다면 생성자는 default 접근 제한을 가진다.   
dafault 접근 제한은 같은 패키지에서는 아무런 제한 없이 생성자를 호출할 수 있으나,   
다른 패키지에서는 생성자를 호출할 수 없도록 한다.   

- private  
    - 생성자 : 클래스(...)   
private 접근 제한은 동일 패키지이건 다른 패키지이건 상관없이 생성자를 호출하지 못하도록 제한한다.   
따라서 클래스 외부에서 new 연산자로 객체를 만들 수 있다.   
오로지 클래스 내부에서만 생성자를 호출할 수 있고, 객체를 만들 수 있다.   

> A, B, C 클래스에서 어떤 컴파일 에러가 생기는지 확인하기

- `A.java` 생성자의 접근 제한   

```java
package sec13.exam02_constructor_access.package1;

public class A {
    //필드
    A a1 = new A(true);       // (o)
    A a2 = new A(1);          // (o)
    A a3 = new A("문자열")    // (o)

    //생성자
    public A(boolean b) { } //public 접근 제한
    A(int b) { }            //default 접근 제한
    private A(String s) { } //private 접근 제한
}
```   
A 클래스 내부에서는 A의 모든 생성자를 호출할 수 있음을 할 수 있다. 

- `B.java` 생성자의 접근 제한

```java
package sec13.exam02_constructor_access.package1;   //패키지 동일

public class B {
    //필드
    A a1 = new A(true);      //(o)
    A a2 = new A(1);         //(o)
    A a3 = new A("문자열");  //(x)  ← private 생성자 접근 불가 (컴파일 에러)
}
```   

- `C.java` 생성자의 접근 제한

```java
package sec13.exam02_constructor_access.package2;   //패키지 다름

import sec13.exam02_constructor_access.package1.A;

public class C {
    //필드
    A a1 = new A(true);     //(o)
    A a2 = new A(1);        //(x)   ← default 생성자 접근 불가 (컴파일 에러)
    A a3 = new A("문자열"); //(x)   ← private 생성자 접근 불가 (컴파일 에러)
}
```   

가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다.   
이럴 경우 여러 개의 객체를 만들지 못하도록 설계해야 하는데 이것을 싱글톤(Singleton) 패턴이라고 한다.   

싱클톤 패턴은 생성자를 private 접근 제한으로 선언하고,   
자신의 유일한 객체를 리턴하는 `getInstance()` 정적 메소드를 선언하는 것을 말한다.   
[[JAVA] Class-02_5.5_싱글톤](https://sun0te.github.io/java/Class_02/)

### 8.3 필드와 메소드의 접근 제한   
필드와 메소드를 선언할 때 고려해야 할 사항은 클래스 내부에서만 사용할 것인지,   
패키지 내에서만 사용할 것인지,    
아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 한다.   

> 이것은 필드와 메소드가 어떤 접근 제한을 갖느냐에 따라 결정된다.   

```java   
    //필드 선언
    [ public | protected | private ] [static] 타입 필드;

    //메소드 선언
    [ public | protected | private ] [static] 리턴 타입 메소드(...) {...}
```
- publc   
    - 생성자
    ```java 
        필드
        메소드(...)   
    ```
public 접근 제한은 모든 패키지에서 아무런 제한 없이 필드와 메소드를 사용할 수 있도록 한다.    
필드와 메소드가 public 접근 제한을 가진다면 클래스도 public 접근 제한을 가져야 한다.   
클래스가 default 접근 제한을 가지게 되면 패키지 안에서만 클래스가 사용되기 때문이다.    

- protected   
    - 생성자
    ```java 
        필드
        메소드(...)   
    ```  
protected 접근 제한은 default 접근 제한과 마찬가지로 같은 패키지에 속하는 클래스에서 클래스에서 필드와 메소드를 사용할 수 있도록 한다.   
차이점은 다른 패키지에 속한 클래스가 해당 클래스의 자식(Child) 클래스라면 필드와 메소드를 사용할 수 있다.   

- default   
    - 생성자
    ```java 
        필드
        메소드(...)   
    ``` 
필드와 메소드를 선언할 때 public 또는 private 를 생략했다면 default 접근 제한을 가진다.   
dafault 접근 제한은 같은 패키지에서는 아무런 제한 없이 필드와 메소드를 사용할 수 있으나,   
다른 패키지에서는 필드와 메소드를 사용할 수 없도록 한다.   

- private  
    - 생성자
    ```java 
        필드
        메소드(...)   
    ```
private 접근 제한은 동일 패키지이건 다른 패키지이건 상관없이 필드와 메소드를 사용하지 못하도록 제한한다.   
오로지 클래스 내부에서만 사용할 수 있다. 

> A, B, C 클래스에서 어떤 컴파일 에러가 생기는지 확인하기

- `A.java` 필드와 메소드의 접근 제한   

```java
package sec13.exam03_field_method_access.package1;

public class A {
    //필드
    public int field;       //public 접근 제한
    int field2;             //default 접근 제한
    private int field3;     //private 접근 제한

    //생성자
    public A() {        // ↓ 클래스 내부일 경우 접근 제한자의 영향을 받지 않는다. 
        field1 = 1;     //(o)
        field2 = 1;     //(o)
        field3 = 1;     //(o)

        method1();      //(o)
        method2();      //(o)
        method3();      //(o)
    }
    
    //메소드
    public void method1() {}    //public 접근 제한
    void method2() {}           //default 접근 제한
    private void method3() {}   //private 접근 제한
}
```

- `B.java` 필드와 메소드의 접근 제한   

```java
package sec13.exam03_field_method_access.package1;  //패키지 동일

public class B {
    public B() {
        A a = new A();
        a.field1 = 1;     //(o)
        a.field2 = 1;     //(o)
        a.field3 = 1;     //(x) ← private 필드 접근 불가 (컴파일 에러)

        a.method1();      //(o)
        a.method2();      //(o)
        a.method3();      //(x) ← private 메소드 접근 불가 (컴파일 에러)
    }
}
```   
패키지가 동일한 B 클래스에서는 A 클래스의 private 필드와 메소드를 제외한 다른 필드와 메소드는 사용할 수 있다.   

그러나 다음과 같이 패키지가 다른 C 클래스에서는 A 클래스의 public 필드와 메소드를 제외한 다른 필드와 메소드를 사용할 수 없다.   

- `C.java` 필드와 메소드의 접근 제한   

```java
package sec13.exam03_field_method_access.package2;  //패키지 다름

public class C {
    public C() {
        A a = new A();
        a.field1 = 1;     //(o)
        a.field2 = 1;     //(x) ← default 필드 접근 불가 (컴파일 에러)
        a.field3 = 1;     //(x) ← private 필드 접근 불가 (컴파일 에러)

        a.method1();      //(o)
        a.method2();      //(x) ← default 메소드 접근 불가 (컴파일 에러)
        a.method3();      //(x) ← private 메소드 접근 불가 (컴파일 에러)
    }
}

```  

## 9. Getter 와 Setter 메소드  
일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다.     
객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨어질 수 있다.

- ex) 자동차의 속도를 외부에서 음수로 변경하면 객체의 무결성이 깨진다.   
    ```java
    myCar.speed = -100;
    ```    

이러한 문제점을 해결하기 위해 객체 지향 프로그래밍에서는    
**메소드를 통해서 데이터를 변경하는 방법** 을 선호한다.    


### 9.1 Setter 메소드
데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.
> Why?   
    메소드는 매개값을 검증해서 유효한 값만 데이터로 저장할 수 있기 때문이다.   
    이러한 역할을 하는 메소드가 `Setter` 이다.   
- ex) 자동차 속도를 setSpeed() 메소드로 변경할 경우 검증 코드 작성하기   
```java
void setSpeed(double speed) {
    if(speed < 0) {         // ┐   매개값이 음수일 경우
        this.speed = 0;     // │   speed 필드에 0으로 저장하고, 
        return;             // ┘   매소드 실행 종료
    } else {
        this.speed = speed;
    }
}
```    

### 9.2 Getter 메소드
외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다.   
객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우도 있다.   
> 이런 경우에는 메소드로 필드값을 가공항 후 외부로 전달하면 된다.   
    이런 메소드가 바로 `Getter` 이다.   
- ex) 자동차의 속도를 마일에서 KM 단위로 환산해서 외부로 리턴해주는 getSpeed() 메소드를 다음과 같이 작성할 수 있다. 
```java
double getSpeed() {
    double km = speed*1.6;  // ┐   필드값인 마일을 km 단위로 환산 후 
    return km;              // ┘   외부로 리턴
}
```

클래스를 선언할 때 가능하다면 필드를 private 로 선언해서 외부로부터 보호하고,   
필드에 대한 Setter 와 Getter 메소드를 작성해서 필드값을 안전하게 변경 / 사용하는 것이 좋다.   
- ex) Setter 와 Getter 메소드를 선언하는 방법이다.    
검증코드나 변환 코드는 필요에 따라 추가해야 한다.   

    ```java
    private 타입 fieldName; //필드 접근 제한자 private

    //Getter
    public 리턴타입 getFieldName() {    // 접근 제한자 : public, 리턴 타입 : 필드타입
        return fieldName;               //  메소드 이름 : get + 필드이름 (첫 문자 대문자)
    }                                   // 리턴값 : 필드값

    //Setter
    public void setFieldName(타입 fieldName) {  // 접근 제한자 : public, 리턴타입 : void
     this.fieldName = fieldName;                // 메소드 이름 : set + 필드이름 (첫 문자 대문자)
    }                                           // 매개 변수 타입 : 필드 타입

    ```   

필드 타입이 boolean 일 경우 Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례이다. 
- ex) strop 필드의 Getter 와 Setter 는 다음과 같이 작성한다.   

    ```java
    private boolean stop;   // 필드 접근 제한자 : private

    //Getter
    public boolean isStop() {   // 접근 제한자 : public, 리턴타입 : 필드 타입
        return stop;            // 메소드 이름 : is + 필드이름 (첫문자 대문자)
    }                           // 리턴값 : 필드값

    //Setter
    public void setStop(boolean stop){  // 접근 제한자 : public, 리턴 타입 : void
        this.stop = stop;               // 메소드 이름 : set + 필드이름 (첫문자 대문자)
    }                                   // 매개 변수 타입 : 필드타입

    ```

ex) 외부에서 필드값을 읽을 수만 있고 변경하지 못하도록 하려면 (읽기 전용)
- `Getter` 메소드만 선언   
- `Setter` 메소드 + private 접근 제한

---

- 이클립스에서 Getter 와 Setter 메소드 자동생성   
    이클립스는 클래스에 선언된 필드에 대해 자동적으로 Getter 와 Setter 메소드를 생성시키는 기능이 있다.    
     1. 필드를 선언   
     2. Menu [Source → Generate Getters and Setters] 선택     
    이렇게 하면 선언된 필드에 대한 Getter 와 Setter 를 자동 생성시킬 수 있는 대화상자가 실행된다.     

### 9.3 실전예제    

 Car 클래스의 speed 와 stop 필드에 대한 Getter 와 Setter를 작성한다.

- `Car.java` Getter 와 Setter 메소드 작성   
    ```java
    public class Car {
        //필드
        private int speed;
        private boolean stop;

        //생성자

        //메소드
        public int getSpeed() {
            return speed;
        }

        public void setSpeed(int speed) {
            if(speed < 0) {
                this.speed = 0;
                return;
            } else {
                this.speed = speed;
            }
        }

        public boolean isStop() {
            return stop;
        }

        public void setStop(boolean stop) {
            this.stop = stop;
            this.speed = 0;
        }
    }
    ```   

- `CarTest.java` Getter 와 Setter 메소드 사용
    ```java
    public class CarTest {
        public static void main(String[] args) {
            Car myCar = new Car();

            //잘못된 속도 변경
            myCar.setSpeed(-50);

            System.out.println("현재 속도 : "+myCar.getSpeed());

            //올바른 속도 변경
            myCar.setSpeed(60);

            //멈춤
            if(myCar isStop()) {
                myCar.setStop(true);
            }

            System.out.println("현재 속도 : "+myCar.getSpeed());

        }
    }
    ```

- 결과값
    - 현재 속도 : 0
    - 현재 속도 : 0


## 10. 어노테이션   

**Info Notice:** 작성 중입니다. 
{: .notice--info}



🌞 정보 : 공부 기록용 블로그입니다. 오타나 내용 오류가 있을 경우 알려주시면 감사하겠습니다.
{: .notice}
