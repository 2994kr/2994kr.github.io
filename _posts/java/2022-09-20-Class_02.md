---
title : "[JAVA] Class 이론 정리 - 2"
layout: single
excerpt: "[인스턴스 멤버와 this, 정적 멤버와 static]"
toc: true
toc_sticky: true
date: 2022-09-20
categories: [Java]
tag: [Object, class, method, field, constructor, method]
author_profile: false
sidebar:
    nav: "docs"
---

# Chapter 06. 클래스 정리 - 2

## 4. 인스턴스 멤버와 this
인스턴스(instance) 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데,   
이들을 각각 <u>인스턴스 필드</u>, <u>인스턴스 메소드</u> 라고 부른다.   

지금까지 작성한 모든 필드와 메소드는 인스턴스 멤버들이었다.   
인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다.   

- ex) Car 클래스에 `gas 필드`와 `setSpeed() 메소드`가 다음과 같이 선언되었다 가정해보자
```java
public class Car {
    //필드
    int gas;
				
    //메소드
    void setSpeed(int speed) {...}
}
```   
- gas 필드와 `setSpeed() 메소드`는 인스턴스 멤버이기 때문에 외부 클래스에서 사용하기 위해서는   
우선 Car 객체(인스턴스)를 생성하고 `참조변수 myCar` 또는 `yourCar` 로 접근해야 한다.
```java
			ex) Car my Car = new Car();
		 	   myCar.gas = 10;
		 	   myCar.setSpeed(60);
	

		  	  Car yourCar = new yourCar();
		  	  yourCar.gas = 20;
		  	  yourCar.setSpeed(80);
```
    위 코드가 실행된 후 메모리 상태를 그림으로 표현하면 다음 그림과 같다.   
    인스턴스 필드 gas 는 객체마다 따로 존재하고,    
    `인스턴스 메소드 setSpeed()` 는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다.



객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로   
객체 내부에서도 인스턴스 멤버에 접근하기 위해 `this` 를 사용할 수 있다.   
- ex) this.model 은 자신이 가지고 있는 model 필드라는 뜻이다.   
	this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우,   
	인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.
    -  ex) 다음은 매개 변수 model 의 값을 필드 model에 저장한다. 
	```java
		Car(String model) {
			this.model = model;
		}
		void setModel(String model) {
			this.model = model;
		}
    ```

## 5. 정적 멤버와 static   
정적(static)은 '고정된' 이란 의미한다.   
정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.   
이들은 각각 <u>정적 필드, 정적 메소드</u> 라고 부른다.   

정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 <u>클래스 멤버</u> 라고도 한다.   

### 5.1 정적 멤버 선언
정적 필드와 정적 메소드를 선언하는 방법은 필드와 메소드 선언 시 `static` 키워드를 추가적으로 붙이면 된다.
- ex) 정적 필드와 정적 메소드를 선언하는 방법
```java
public class 클래스 {
	//정적 필드
	static 타입 필드 [=초기값];
	
	//정적 메소드
	static 리턴 타입 메소드( 매개변수선언, ...) {...}
}
```
정적 필드와 정적 메소드 클래스에 고정된 멤버이므로 클래스로더가 클래스(바이트 코드)를
로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다.   
따라서 클래스 로딩이 끝나면 바로 사용할 수 있다.   

![image](https://user-images.githubusercontent.com/50590124/191284111-6bb774b3-fdcf-4385-a2a8-7ccc9c5b7a0a.png)

> 필드를 선언할 때, <u>인스턴스 필드로 선언할 것인가</u>, 아니면 <u>정적 필드로 선언할 것인가</u>의 판단 기준   

객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고,   
객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면 정적 필드로 선언하는 것이 좋다.   
- ex) `Calculator 클래스`에서 원의 넓이나 둘레를 구할 때 필요한 파이는   
	Calculator 객체마다 가지고 있을 필요가 없는 변하지 않는 공용적 데이터이므로 `정적 필드`로 선언하는 것이 좋다.   
	그러나 객체별로 색깔이 다르다면 색깔은 `인스턴스 필드`로 선언해야 한다.   
	```java
	public class Calculator {
		
		String color;			// 계산기별로 색깔이 다를 수 있다. 
		static double pi = 3.14159;	// 계산기예서 사용하는 파이 값은 동일
	}
    ```


> 메소드의 경우, <u>인스턴스 메소드</u>인지 <u>정적 메소드</u>로 선언할 것인지의 판단 기준

인스턴스 필드를 이용해서 실행해야 한다면 인스턴스 메소드로 선언하고, 인스턴스 필드를 이용하지 않는다면 정적 메소드로 선언한다.   	
- ex) `Calculator 클래스`의 덧셈, 뺄셈 기능은 인스턴스 필드를 이용하기 보다는   
	외부에서 주어진 매개값들은 가지고 덧셈과 뺄셈을 수행함므로 `정적 메소드`로 선언하는 것이 좋다.     
	그러나. 인스턴스 필드인 색깔을 변경하는 메소드는 `인스턴스 메소드`로 선언해야 한다.
    ```java
	public class Calculator {
		String color;						//인스턴스 필드
		void setColor(String color) { this.color = color; }	//인스턴스 메소드	
		static int plus(int x, int y) { return x + y; }		//정적 메소드
		static int minus(int x, int y) { return x + y; }	       //정적 메소드
	}
    ```

   

### 5.2 정적 멤버 사용
클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 
`클래스 이름`과 함께 `도트(.) 연산자`로 접근한다. 
- ex) 
```java
		클래스.필드;
		클래스.메소드( 메개값, ...);
```   		
- ex) Calculator 클래스가 다음과 작성
```java		
		public class Calculator {
			static double pi = 3.14159;
			static int plus(int x, int y) {...}
			static int minus(int x, int y) {...}
		}
```
	
- ex) 정적 필드 pi와 정적 메소드 plus(), minus() 는 다음과 같이 사용할 수 있다. 
```java
		double result1 = 10 * 10 * Calculator.pi;
		int result2 = Calculator.plus(10, 5);
		int result3 = Calculator.minus(10, 5);
```	
- ex) 정적 필드와 정적 메소드는 원칙적으로는 클래스 이름으로 접근해야 하지만   
다음과 같이 객체 참조 변수로도 접근이 가능하다. 
```java	
		Calculator my Calcu = new Calculator();
		double result1 = 10 * 10 * myCalcu.pi;
		int result2 = myCalcu.plus(10, 5);
		int result3 = myCalcu.minus(10, 5);
```		
	하지만. 정적 요소는 클래스 이름으로 접근하는 것이 좋다.   
	이클립스에서는 정적 멤버를 클래스 이름으로 접근하지 않고 객체 참조 변수로 접근했을 경우, 경고 표시가 나타난다. 

### 5.3 정적 초기화 블록
정적 필드는 다음과 같이 필드 건언과 동시에 초기값을 주는 것이 보통이다. 
- ex) 
```java
	static double pi = 3.14159;
```

그러나. 계산이 필요한 초기화 작업이 있을 수 있다.   
인스턴스 필드는 생성자에서 초기화하지만,   
정적 필드는 객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 없다.   
생성자는 객체 생성 시에만 실행되기 때문이다.   

> 그렇다면 정적 필드를 위한 초기화 작업은 어디에서 해야 하는가?  
자바는 정적 필드의 복잡한 초기화 작업을 위해서 정적 블록(static block)을 제공한다. 
- ex) 정적 블록의 형태
```java
	static { 
		...
	}
```
정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다.   
정적 블록은 클래스 내부에 여러개가 선언되어도 상관없다.   
클래스가 메모리로 로딩될 때 선언된 순서대로 실행된다.   
		
### 5.4 정적 메소드와 블록 선언 시 주의할 점
정적 메소드와 정적 블록을 선언할 때 주의할 점은 객체가 없어도 실행된다는 특징 때문에,   
이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.   
또한 객체 자신의 참조인 this 키워드도 사용이 불가능하다.   

- ex) 그래서 다음 코드는 `컴파일 오류`가 발생한다.   
```java
	public class ClassName {
	//인스턴스 필드와 메소드
	int field1;
	void method1() { ... }
	
	//정적 필드와 메소드
	static int field2;
	static void method2() { ... }

	//정적 블록
	static {
		field1 = 10;	// (X)	컴파일 에러
		method1();	// (X)	컴파일 에러
		field2 = 10;	// (O)
		method2();	// (O)	
	
	}
	
	//정적 메소드
	static {
		this.field1 = 10;	// (X)	컴파일 에러
		this.method1();		// (X)	컴파일 에러
		field2 = 10;		// (O)
		method2();		// (O)
	}
	
	}
```


- 정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 다음과 같이 객체를 먼저 생성하고 참조 변수를 접근해야 한다.
```java
		static void Method3() {
			ClassName obj = new ClassName();
			obj.field1 = 10;
			odj.method1();
		}
```

`main() 메소드`도 동일한 규칙이 적용된다.   
main() 메소드도 정적(static) 메소드이므로 객체 생성 없이 인스턴스 필드와 인스턴스 메소드를 main() 메소드에서 바로 사용할 수 없다. 
- ex) 잘못 코딩된 것 
```java
	public class Car {
		int speed;

		void run() { ... }
			
		public static void main(String[] args) {
		speed = 60; 	//(X) 컴파일 에러
		run(); 		//(X) 컴파일 에러
		}
	}
```

- ex) main() 메소드를 올바르게 수정한 것
```java
	public static void main(String[] args) {
		Cat myCar = new Car();
		myCar.speed = 60;
		myCar.run();
	}
```


### 5.5 싱글톤(Singleton)
가끔 전체 프로그램에서 `단 하나의 객체`만 만들도록 보장해야 하는 경우가 있다.   
단 하나만 생성된다고 해서 이 객체를 `싱글톤(sinfleton)` 이라고 한다. 
	
> 싱글톤을 만드려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.   
생성자를 호출할 만큼 객체가 생성되기 때문이다.   
생성자를 외부에서 호출할 수 없도록 하여면 생성사 앞에 `private 접근 제한자`를 붙여주면 된다.   
외부에서 생성자 호출을 막기 위해 private 를 붙여둔다.  
	그리고 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다.   
    참고로 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다.   
	
정적 필드로 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다. 	   
대신 외부에서 호출할 수 있는 정적 메소드인 `getInstance()`를 선언하고    
정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다. 			
- ex) 싱글톤을 만드는 코드
```java
		public class 클래스 {
			//정적 필드
			private static 클래스 singleton = new 클래스();
		
			//생성자
			private 클래스() {}
		
			//정적 메소드
			static 클래스 getInstance() {
				return singleton;
			}
		
		}
```

외부에서 객체를 얻는 유일한 방법은 `getInstance()` 메소드를 `호출`하는 방법이다.   
getInstance() 메소드는 단 하나의 객체만 리턴하기 때문에    
- ex) 아래 코드에서 변수 1과 변수 2는 동일한 객체를 참조한다.
```java		
	클래스 변수1 = 클래스.getInstance();
	클래스 변수2 = 클래스.getInstance();
```


🌞 정보 : 공부 기록용 블로그입니다. 오타나 내용 오류가 있을 경우 알려주시면 감사하겠습니다.
{: .notice}
